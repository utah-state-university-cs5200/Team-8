prioritize getting a minimal lobby client and player client that can handle assigning a player a player id
	goal: no more than 5 files excluding tests
once that set up is accomplished which will likely have a lot of specific solutions, try to generalize, figure out how we're using things and where can make specific things like sockets passed in as arguments so they are easily stubbed out
once interface pattern decided on, delegating work should be easier

goal:
	a lobby server that can give a player client a player_id
	lobby will need:
		a socket to recieve+send udp packets
		logic to respond to message requesting id
		logic to give unique player_id
		logic to send unique player_id
	player will need
		a socket to receive+send udp packets
		logic to send request
		logic to parse response
		logic to set new player_id internally


thoughts:
	uniqueness of messages:
		all senders have the ability to give internally generated messages unique IDs
		all senders also have unique ID's for themselves
			only one lobby
			lobbby gives out player ids
			lobby gives out game id's
		between unique sender id and internal unique message id, message is uniquely identified
		ergo: if a message has included it the sender ID and the senders generated message id, it will be unique in that aspect
		problem: we do not generate or include message id on messages, only type id and usually sender id
		problem: when generating a message from decoded data in factory, we need the message to use the provided ID, not a generated one
		work arounds:
			1: have message init distinguish between generated from byte code or not
			2: have message id tabulated on send,
			3: have message id tabulated by relevant senders and give messageid as part of arguments

		wanted: messages to be uniquely identifiable in almost all cases
		solution: a decoded message must have a sender id and a message id
		ergo: in the process of generating a message, it must have a sender id and a message id

	conversations and their behavior:
		a conversation object consists of a list of messages
		a conversation can infer from the last message what next action should be taken or message should be sent
		a conversation would need to know which client it belongs to know which action should be taken
			ie: a player client should never be assigning new player ids or making game servers
			ergo: dedicated objects for each kind of message would need sufficient functional detail to act on either clients behalf
				or have twice as many conversation classes
				or have a function that responds with a function name that the client uses to check against a registry of allowable actions and if it can, it does
		possible flow:
			1: client receives a message
			2: client puts decoded message in appropriate conversation
		separate flow
			1: client inspects all conversations for suggestion for next action
			2: if actionable, act, else, wait, go back to 1
		if conversation has a method #nextAction and it returns a string, what is the easiest way to invoke a function given a string
			dir(self) #generates large list which includes both instance variables and instance methods
			getattr(self, conversation.nextAction) #if action in is a valid method
		needed:
			mapping between message types and conversation types
				ie: hello and playerid belong to add player to network conversation
			conversation id needed to indicate which conversation is being modified
				initiating message (which will have a unique id, excepting for the hello message) can be used
				hello conversation will have player IP address as unique ID?
		thought:
			client.conversations -> dictionary with {(message_id, sender_id): conversation_object}
		certain messages prompt creation of a new conversation object
		a conversation object would need to be put into the conversations dictionary upon creation
		if the conversation created is the hello conversation, generate a unique player id and set that as sender id for conversation

def ack_player(message_responding_to):
	ack(message_responding_to)

def ack(message_responding_to):
	#however we decide to ack

def clean_up_conversations(self, conv_id):
	del(self.conversations[conv_id])

Conversation -> NewPLayerConversation
